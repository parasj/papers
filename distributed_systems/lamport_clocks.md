# Time, Clocks, and the Ordering of Events in a Distributed System

Lamport presents his classic paper about logical clocks. The key idea in this paper is the concept of a "happens-before" relationship. This implies 2 conditions: A) a -> b implies C(a) < C(b) and B) the time a message is received by node J must be greater than the time the message was sent by node I. Thus, condition 1 necessitates each process increments it's clock whenever there is any event. Condition 2 necessitates each node update it's clock to the max of the other node's clock (plus 1) and it's own.

This partial ordering is useful to establish causation of messages. However, to produce a total ordering, Lamport introduces the notion of tie-breaking based on a deterministic ordering of processes. This reminds me of the tie-breaking introduces in CRDTs.

Finally, Lamport introduces a way to create physical clocks through the use of a bound on the error of a physical clock. He states that each physical clock has a "skew" as in the rate of time passage that has a small error $$\kappa$$. Each clock then needs to be synchronized periodically to ensure the drift with clocks is bounded to $$\frac{\epsilon}{1-\kappa} \leq \mu$$ where $$\mu$$ is the maximum bound on error for physical ordering to hold. He bounds $$\epsilon \approx d(2\kappa\tau+\xi)$$. This basically means that the system must send messages to synchronize clocks frequently enough such that the max delay and max clock error both are much smaller than the synchronization frequency.

I spent a bit more time summarizing this paper as it's a classic. I like this paper of it's simplicity and for the fact that it doesn't overwhelm the reader with notation while still "proving" the notion of a logical clock, total ordering and physical clock error bounds meeting the conditions he specified (proof as in a mathematical argument to the reader). However, I have one criticism for the paper - the paper should have covered a brief note about how logical clocks, distributed mutual exclusion and other algorithms were resilient to failure. They assume ordered delivery and complete delivery of messages, and they have no recovery protocol on node failure.
